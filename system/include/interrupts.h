#ifndef INTERRUPTS_H
#define INTERRUPTS_H

#include <stdbool.h>

/*
 * Module to configure interrupts for Raspberry Pi.
 *
 * Author: Philip Levis <pal@cs.stanford.edu>
 * Author: Pat Hanrahan <hanrahan@cs.stanford.edu>
 * Author: Julie Zelenski <zelenski@cs.stanford.edu>
 *
 * Last update:   February 2020
 */

/*
 * `interrupts_init`
 *
 * Initialize interrupts. The init function must be called once
 * before any calls to other functions in the interrupts module. 
 * The init function configures interrupts to a clean state.
 * 
 *    - vector table is copied to destination address 0
 *    - all interrupt sources are off
 *    - all attached handlers are removed
 *    - interrupts are globally disabled
 */
void interrupts_init(void);

/*
 * `interrupts_global_enable`
 *
 * Turns on interrupts system-wide. Interrupts will be generated 
 * for events on sources that have attached handlers.
 */
void interrupts_global_enable(void);

/*
 * `interrupts_global_disable`
 *
 * Turns off all interrupts system-wide. No interrupts will be generated. 
 * Does not remove/disable attached handlers/sources, just temporarily
 * suspends interrupt generation. Use `interrupts_global_enable` to 
 * resume generating interrupts.
 */
void interrupts_global_disable(void);

/* 
 * This typedef gives a nickname to the type of function pointer used as
 * a handler callback. A handler is attached to an interrupt source. When
 * an interrupt is generated by that source, the handler is called to
 * process it. A handler takes one argument of type unsigned int
 * (value of interrupted pc) and returns a bool, which indicates whether 
 * the interrupt was successfully processed.
 */
typedef bool (*handler_fn_t)(unsigned int);

/* 
 * `interrupts_attach_handler`
 *
 * Attach client's handler function to a given interrupt source. Attaching a
 * handler enables interrupts on the source and stores the function
 * pointer to be called back when an interrupt is generated on that source.
 * Asserts if failed to install handler (i.e. vector table not properly 
 * initialized or too many attached handlers).
 *
 * An interrupt source is identified by number. Valid source numbers are 
 * listed below in the `interrupt_source` enumeration.
 * The sources we will commonly use are
 *     INTERRUPTS_GPIO3 for gpio interrupts (source shared by all gpios)
 *     INTERRUPTS_BASIC_ARM_TIMER_IRQ  for armtimer interrupts
 * If requested source is invalid, makes no changes to handlers.
 *
 * It is supported to attach more than one handler for a given source.
 * This is needed because events on multiple inputs (e.g. set of gpio's) may
 * generate interrupts on the same source. 
 *
 * How interrupts are dispatched to the attached handler:
 * When an interrupt is received, the dispatch function cycles through
 * the attached handlers one by one, stopping after first that processes it.
 * It is the responsibility of the client's handler function to check 
 * whether the event is of the specific sort it can process. If so, 
 * the handler should process and clear the event and return true to 
 * indicate the interrupt has been handled and no further processing is 
 * needed. If the handler does not process this interrupt, it should do 
 * nothing and return false; dispatch will pass along to other handlers.
 * Dispatch raises an assert if return value from the handler
 * doesn't match whether event was cleared, i.e. if handler returns true,
 * it should have cleared the event and if handler returns false, the
 * event should not have been cleared.
 *
 * The handlers are called in sequence, according to the order in
 * which they were attached. Dispatch stops at the first handler that
 * handles the interrupt. If it is necessary that your handler gets first
 * dibs on processing the interrupt, be sure to attach it before any others.
 */
void interrupts_attach_handler(handler_fn_t fn, unsigned int source);


enum interrupt_source {
    INTERRUPTS_SHARED_FIRST = 29,
    INTERRUPTS_AUX             = 29,
    INTERRUPTS_I2CSPISLV       = 43,
    INTERRUPTS_PWA0            = 45,
    INTERRUPTS_PWA1            = 46,
    INTERRUPTS_CPR             = 47,
    INTERRUPTS_SMI             = 48,
    INTERRUPTS_GPIO0           = 49,
    INTERRUPTS_GPIO1           = 50,
    INTERRUPTS_GPIO2           = 51,
    INTERRUPTS_GPIO3           = 52,
    INTERRUPTS_VC_I2C          = 53,
    INTERRUPTS_VC_SPI          = 54,
    INTERRUPTS_VC_I2SPCM       = 55,
    INTERRUPTS_VC_UART         = 57,
    INTERRUPTS_SHARED_END,

    INTERRUPTS_BASIC_BASE      = 64,
    INTERRUPTS_BASIC_ARM_TIMER_IRQ = INTERRUPTS_BASIC_BASE,
    INTERRUPTS_BASIC_ARM_MAILBOX_IRQ,
    INTERRUPTS_BASIC_ARM_DOORBELL_0_IRQ,
    INTERRUPTS_BASIC_GPU_0_HALTED_IRQ,
    INTERRUPTS_BASIC_GPU_1_HALTED_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_1_IRQ,
    INTERRUPTS_BASIC_ACCESS_ERROR_0_IRQ,
    INTERRUPTS_BASIC_END
};

/* Above interrupt source numbers taken from table in BCM2835 Sec 7.5
 * I quote: "The table has many empty entries. These should not be
 *           enabled as they will interfere with the GPU operation."
 */


#endif
